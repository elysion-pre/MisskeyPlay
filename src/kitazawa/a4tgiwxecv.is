/// @ 0.19.0
// ããŸã–ã‚ãƒšã‚¢ãƒ¼ã‚º
// Copyright (c) 2025 @elysion
// This script is licensed under the MIT
// https://opensource.org/licenses/mit-license.php

let version = "1.0.0"

let PLAY_TAG =  "#KITAZAWA_PAIRS"
let PLAY_URL = if exists THIS_URL THIS_URL else `{SERVER_URL}/play/a4tgiwxecv`
let PLAY_ID = if exists THIS_ID THIS_ID else PLAY_URL

let random = eval {
  let id = if exists USER_ID USER_ID else Util:uuid()
  // ã‚·ãƒ¼ãƒ‰ãŒã€ŒPLAY ID+ãƒ¦ãƒ¼ã‚¶ãƒ¼ID+ä»Šæ—¥ã®æ—¥ä»˜ã€ã§ã‚ã‚‹ä¹±æ•°ç”Ÿæˆå™¨ã‚’ç”¨æ„
//  Math:gen_rng(`{PLAY_ID}-{id}-{Date:year()}-{Date:month()}-{Date:day()}`)
  // ã‚·ãƒ¼ãƒ‰ãŒã€ŒPLAY ID+ãƒ¦ãƒ¼ã‚¶ãƒ¼ID+ãƒŸãƒªç§’ã€ã§ã‚ã‚‹ä¹±æ•°ç”Ÿæˆå™¨ã‚’ç”¨æ„
  Math:gen_rng(`{PLAY_ID}-{id}-{Date:year()}-{Date:month()}-{Date:day()}-{Date:minute()}-{Date:second()}-{Date:millisecond()}`)
}

// ã‚«ãƒ¼ãƒ‰ã®ç¨®é¡
let CARD_TYPES = 12
// ã‚«ãƒ¼ãƒ‰ã®æšæ•°
let CARD_COUNT = CARD_TYPES * 2

// ã‚«ãƒ¼ãƒ‰è£é¢ã®çµµæŸ„
let BACK_OF_CARD_MARK = ":icon_kitazawamisuki:"

// ããŸã–ã‚ãƒšã‚¢ãƒ¼ã‚ºã§ä½¿ç”¨ã™ã‚‹çµµæ–‡å­—ã‚«ãƒ†ã‚´ãƒª
// pagesã®jsonãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
// https://{SERVER_URL}/@elysion/pages/kitazawa_pairs_data
let EMOJI_LIST = eval {
  var data = null
  let pages_data = Mk:api("pages/show", {
    name: "kitazawa_pairs_data"
    username: "elysion"
  })
  if (Core:type(pages_data) == "error") {
    Core:abort([
      `pagesã«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚`
      `{SERVER_URL}/@elysion/pages/kitazawa_pairs_data`
      `ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’åœæ­¢ã—ã¾ã™ã€‚`
    ].join(Str:lf))
  } else {
    data = Json:parse(pages_data.content[0].text)
  }
  data
}

// é…åˆ—ã®ã‚·ãƒ£ãƒƒãƒ•ãƒ«
// å‚è€ƒ: https://qiita.com/pure-adachi/items/77fdf665ff6e5ea22128
// param: array<arr>
// return: <arr>
@shuffle(array) {
  var i = array.len
  for i {
    let k = Math:floor(random() * i)
    [array[k], array[i - 1]] = [array[i - 1], array[k]]
    i -= 1
  }
  array
}

// ã‚«ãƒ¼ãƒ‰
// param: mark<num>
@Card(mark) {
  let this = {
    mark: -1
    flipped: false
    matched: false
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    constructor: @(mark) {
      this.mark = mark
      this.flipped = false
      this.matched = false
      this
    }
    setMark: @(mark) { this.mark = mark }
    setFlipped: @(f) { this.flipped = f }
    setMatched: @(f) { this.matched = f }

    getMark: @() { return this.mark }
    getFlipped: @() { return this.flipped }
    getMatched: @() { return this.matched }
  }
  this.constructor(mark)
}

// ãƒ‡ãƒƒã‚­
@Deck() {
  let this = {
    cards: []
    // ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    constructor: @() {
      this.cards = Arr:create(CARD_COUNT)
      this
    }
    getCard: @(no) { return this.cards[no] }

    // å±±æœ­ä½œæˆ
    create: @() {
      var n = 0
      for (let i = 0, CARD_TYPES) {
        this.cards[n] = Card(i)
        this.cards[n+1] = Card(i)
        n += 2
      }
      shuffle(this.cards)
    }
  }
  this.constructor()
}

@Game() {
  var marks = null
  var deck = null
  var prev_card = null
  var fClick = false
  var flipp_count = 0

  // åˆæœŸåŒ–
  @init() {
    marks = []
    createMark()

    deck = Deck()
    deck.create()

    prev_card = null
    fClick = true
    flipp_count = 0

    main()
  }
  // çµµæŸ„é¸å®š
  @createMark() {
    render([
      Ui:C:container({
        children: [
          Ui:C:mfm({
            text: [
              `$[x2 Now Loading]`
              `ã‚«ã‚¹ã‚¿ãƒ çµµæ–‡å­—èª­ã¿è¾¼ã¿ä¸­$[bounce .]$[bounce.delay=0.2s .]$[bounce.delay=0.4s .]`
            ].join(Str:lf)
          })
        ]
        align: "center"
      })
    ])
    
    // 12ç¨®é¡ãªã‹ã£ãŸå ´åˆã®è£œæ¬ è¦å› 
    let tmp_emojis = [
      ":kenkoba:"
      ":kenkoba_:"
      ":kenkoba__:"
      ":broccobayashi:"
      ":child_izumoto:"
      ":ha:"
      ":erufu_n:"
      ":mimicchi:"
      ":marucchi:"
      ":endoukenichi:"
      ":tamori_:"
      ":tamori:"
    ]
    
    // ãƒ©ãƒ³ãƒ€ãƒ ã«ã‚«ãƒ†ã‚´ãƒªã‚’é¸å®š
    let category = EMOJI_LIST.pairs_categories[random(0, (EMOJI_LIST.pairs_categories.len - 1))]

    // ã‚«ãƒ†ã‚´ãƒªã®çµµæ–‡å­—ã‚’æŠ½å‡ºã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    marks = shuffle(CUSTOM_EMOJIS.filter(@(emoji) {
      emoji.category == category
    }).map(@(v) {
      `:{v.name}:`
    }))
    
    // marksã®çµµæ–‡å­—æ•°ãŒ12å€‹ä»¥ä¸‹ã®å ´åˆã¯12å€‹ã«ãªã‚‹ã¾ã§è¿½åŠ 
    if marks.len < CARD_TYPES {
      loop {
        if marks.len >= CARD_TYPES break
        if random(0, 1) == 0 marks.push(tmp_emojis.shift()) else marks.push(tmp_emojis.pop())
      }
    }

    // marksã®çµµæ–‡å­—æ•°ãŒ12å€‹ä»¥ä¸Šã‚ã‚‹å ´åˆã¯12å€‹ã«ãªã‚‹ã¾ã§å‰Šæ¸›
    if marks.len > CARD_TYPES {
      loop {
        if marks.len <= CARD_TYPES break
        let no = random(0, (marks.len - 1))
        marks.remove(no)
      }
    }
  }
  // UIæ›´æ–°
  @updateUI() {
    Ui:get("cardsMfm").update({
      text: [
        `$[tada.speed=0s {createDeckMfm()}]`
        `æ‰‹æ•°: {flipp_count}å›`
      ].join(Str:lf)
      onClickEv: @(e) {
        if Core:type(e.to_num()) == "num" {
          clickCard(e.to_num())
        } else {
          // error
        }
      }
    })
  }
  // ã‚«ãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯å‡¦ç†
  // param: no<num>
  @clickCard(no) {
    let card = deck.getCard(no)
    if !fClick || (prev_card != null && prev_card == card) return 0
    
    fClick = false

    let flipped = card.getFlipped()
    let matched = card.getMatched()
    // ã‚ãã‚‰ã‚Œã¦ã„ãªã„ã‹ã¤ãƒãƒƒãƒã—ã¦ã„ãªã„
    if !(flipped || matched) {
      // ã‚ãã‚‹
      card.setFlipped(true)
      // update UI
      updateUI()
    }

    // 1æšç›®
    if prev_card == null {
      prev_card = card
      fClick = true
    } else {
      // 2æšç›®ãªã‚‰1æšç›®ã¨ãƒãƒƒãƒã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
      if prev_card.getMark() == card.getMark() {
        // ãƒãƒƒãƒ
        prev_card.setMatched(true)
        card.setMatched(true)
      } else {
        // è£é¢ã«æˆ»ã™
        prev_card.setFlipped(false)
        card.setFlipped(false)
        // 1ç§’å¾…ã¤
        Core:sleep(1000)
      }

      prev_card = null
      flipp_count += 1

      // update UI
      updateUI()

      // ã™ã¹ã¦ã®ã‚«ãƒ¼ãƒ‰ãŒãƒãƒƒãƒã—ã¦ã„ãŸã‚‰çµæœå‡¦ç†ã¸
      if deck.cards.every(@(v) { v.matched }) {
        result()
      } else {
        fClick = true
      }
    }
  }
  // MFMä½œæˆ
  // return: <str>
  @createDeckMfm() {
    let cardsMfm = []
    let row = CARD_COUNT / 4
    let column = CARD_COUNT / 6
    // 6 x 4
    for (let i = 0, column) {
      let mfm = []
      for (let j = 0, row) {
        let no = (i * row) + j
        let card = deck.getCard(no)
        let mark = marks[card.getMark()]
        if card.getFlipped() {
          // è¡¨é¢
          mfm.push(`$[border.radius=5 $[bg.color=fff5 {mark}]]`)
        } else {
          // è£é¢
          mfm.push(`$[clickable.ev={no.to_str()} $[border.radius=5 $[bg.color=030 {BACK_OF_CARD_MARK}]]]`)
        } 
      }
      cardsMfm.push(mfm.join())
    }
    cardsMfm.join(Str:lf)
  }
  // ãƒ¡ã‚¤ãƒ³å‡¦ç†
  @main() {

    render([
      Ui:C:container({
        children: [
          Ui:C:mfm({
            text: `$[x2 $[fg.color=ff0000 K]$[fg.color=ff7700 I]$[fg.color=ffea00 T]$[fg.color=9dff00 A]$[fg.color=26ff00 Z]$[fg.color=00ff4d A]$[fg.color=00ffc4 W]$[fg.color=00c4ff A]$[fg.color=004dff  ]$[fg.color=2600ff P]$[fg.color=9d00ff A]$[fg.color=ff00ea I]$[fg.color=ff0077 R]$[fg.color=ff0000 S]]`
          })
        ]
        align: "center"
//        bgColor: "#030"
      })
      Ui:C:container({
        children: [
          Ui:C:mfm({}, "cardsMfm")
        ]
        align: "center"
//        bgColor: "#030"
//        rounded: true
      })
    ])
    // update UI
    updateUI()
  }
  // çµæœ
  @result() {

    // çµæœè¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆ
    let resultMfm = [
      `$[sparkle $[tada.speed=0s {createDeckMfm()}]]`
      `æ‰‹æ•°: {flipp_count}å›`
    ].join(Str:lf)
    
    // æŠ•ç¨¿ç”¨ãƒ†ã‚­ã‚¹ãƒˆ
    let postText = [
      `<center>`
      resultMfm
      PLAY_TAG
      PLAY_URL
      `</center>`
    ].join(Str:lf)

    render([
      Ui:C:container({
        children: [
          Ui:C:mfm({
            text: "$[x2 $[rainbow $[fg.color=ff0000 ğ¶]$[fg.color=ff6f00 ğ‘œ]$[fg.color=ffd900 ğ‘›]$[fg.color=b7ff00 ğ‘”]$[fg.color=48ff00 ğ‘Ÿ]$[fg.color=00ff26 ğ‘]$[fg.color=00ff91 ğ‘¡]$[fg.color=00ffff ğ‘¢]$[fg.color=0091ff ğ‘™]$[fg.color=0026ff ğ‘]$[fg.color=4800ff ğ‘¡]$[fg.color=b700ff ğ‘–]$[fg.color=ff00d9 ğ‘œ]$[fg.color=ff006f ğ‘›]$[fg.color=ff0000 ğ‘ ]]]"
          })
        ]
        align: "center"
//        bgColor: "#030"
      })
      Ui:C:container({
        children: [
          Ui:C:mfm({
            text: resultMfm
          })
        ]
        align: "center"
//        bgColor: "#030"
//        rounded: true
      })
      Ui:C:container({
        children: [
          Ui:C:postFormButton({
            text: "æŠ•ç¨¿ã™ã‚‹"
            form: {
              text: postText
            }
            primary: true
            rounded: true
          })
        ]
        align: "center"
      })
    ])
  }
  // æç”»
  // param: components<arr>
  @render(components) {
    Ui:render(components)
  }

  init()
}
Game()
